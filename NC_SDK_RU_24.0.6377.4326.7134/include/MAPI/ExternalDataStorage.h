
#pragma once

//==================================================================================================

// Хэндл объекта во внешнем хранилище.
// Предполагается некое уникальное целое число, уникальное в пределах хранилища.

#ifndef EHOBJ_DEFINED
#define EHOBJ_DEFINED
typedef __int64 EHOBJ;
#endif

// Хэндл документа во внешнем хранилище.
// Предполагается некое уникальное целое число, уникальное в пределах хранилища.

#ifndef EHDOC_DEFINED
#define EHDOC_DEFINED
typedef __int64 EHDOC;
#endif

//==================================================================================================

struct IExtDocObjecsIterator
{
	virtual ~IExtDocObjecsIterator() {}

	virtual bool isDone() const = 0;
	virtual bool next() = 0;
	virtual EHOBJ handle() = 0;
};

typedef std::shared_ptr<IExtDocObjecsIterator> IExtDocObjecsIteratorPtr;
//==================================================================================================
// 
// Интерфейс доступа к данным во внешнем хранилище

struct IExternalDataStorage
{
	virtual ~IExternalDataStorage() {}

	//..............................................................................................
	// Управление документами

	// Создать документ
	virtual EHDOC  CreateDoc() = 0;

	// Создать документ для временного хранения.
	// Все данные такого документа после закрытия будут удалены.
	// Используется для временного хранения данных вне оперативной памяти.
	virtual EHDOC  CreateTempDoc(__int64 userTmpID) = 0;

	// Метод возвращает хэндл временного документа по пользовательскому идентификатору.
	virtual EHDOC  GetTempDocByIserID(__int64 userTmpID) = 0;

	virtual IExtDocObjecsIteratorPtr GetDocumentObjectsIterator(EHDOC hDoc) = 0;

	// Удалить все временные данные для указанного документа.
	// Это неактивные временные состояния объектов документа.
	// Как только документ в редакторе закрывается, можно разом удалить все временные данные (вроде Undo стэка)
	// одним вызовом.
	virtual bool   OnCloseDocument(EHDOC hDoc) = 0;

	// Проверка, является ли документ действительным в хранилище.
	virtual bool   IsValidDocument(EHDOC hDoc) = 0;

	//..............................................................................................
	// Управление временем жизни объекта

	// Звать в момент создания объекта, чтобы в хранилище появилась соответствующая сущность.
	virtual EHOBJ  AddObjectToDoc(EHDOC hDoc) = 0;

	// Звать в ответ на событие об удалении объекта из чертежа
	virtual bool   EraseObject(EHOBJ hObj) = 0;

	// Звать в ответ на восстановление объекта в чертеже (Undo удаления)
	// В этом случае для объекта должна быть в хранилище сущность, помеченная для удаления.
	virtual bool   UneraseObject(EHOBJ hObj) = 0;

	// Проверка, является ли объект действительным в хранилище.
	virtual bool   IsValidObject(EHOBJ hObj) = 0;

	// Присвоить объекту хэндл, уникальный в пределах документа.
	virtual bool   SetObjHandleInDoc(EHOBJ hObj, __int64 handleInDoc) = 0;

	// Получить ID объекта по документу и документному хэндлу.
	virtual EHOBJ  GetObjIdByDocHandle(EHDOC hDoc, __int64 handleInDoc) = 0;

	//..............................................................................................
	// Управление данными объекта

	// Положить часть данных объекта в хранилище.
	// idData - некое число, определяющее тип сохраняемых данных, значениями управляет объект.
	// idObjState - состояние объекта, для которого выполняется запись данных. 0 - текущее состояние.
	// Если размер данных = 0, данные удаляются из хранилища.
	virtual bool   PutObjectData(EHOBJ hObj, DWORD idData, const void* pData, size_t szData, DWORD idObjState = 0) = 0;

	// Удалить указанные данные объекта.
	// idObjState - состояние объекта, для которого выполняется запись данных. 0 - текущее состояние.
	virtual bool   DeleteObjectData(EHOBJ hObj, DWORD idData, DWORD idObjState = 0) {
		return PutObjectData(hObj, idData, NULL, 0, idObjState);
	}

	// Получить размер данных для объекта
	// idObjState - состояние объекта, для которого выполняется запись данных. 0 - текущее состояние.
	virtual size_t GetObjectDataSize(EHOBJ hObj, DWORD idData, DWORD idObjState = 0) = 0;

	// Получить данные объекта в указанный буфер.
	// Размер предварительно получить методом GetObjectDataSize.
	// idObjState - состояние объекта, для которого выполняется получение данных. 0 - текущее состояние.
	virtual bool   GetObjectData(EHOBJ hObj, DWORD idData, IN size_t szBuf, OUT void* pBuf, DWORD idObjState = 0) = 0;

	//..............................................................................................
	// Управление состояниями объекта, Undo/Redo
	// "Состояние объекта" идентифицируется кодом - простое число, уникальное для одного объекта.
	// По сути является слотом для набора данных.
	// Файлу, в котором хранится объект, соответствует одно состояние - текущее. Его код = 0
	// Кроме текущего состояния, объект может иметь несколько других состояний, используемых для Undo.
	// При вызове PurgeDocTempData все состояния кроме текущего будут удалены.

	// Метод создаёт новое состояние объекта для Undo и возвращает его код.
	// При этом хранилище должно наследовать для этого состояния все данные текущего.
	// Метод нужно звать в момент начала записи данных для Undo объекта.
	virtual DWORD  CreateObjStateForUndo(EHOBJ hObj) = 0;

	// Взять для текущего состояния данные из указанного Undo-состояния.
	// Метод нужно звать в ответ на зачитывании данных в редакторе из Undo-стрима объекта.
	virtual bool   UndoObjState(EHOBJ hObj, DWORD idUndoState) = 0;
};

typedef std::shared_ptr<IExternalDataStorage> IExternalDataStoragePtr;

// TODO
// Данные объекта в виде текста, чтобы можно было в хранилище держать diff текста между состояниями.
// 
//==================================================================================================
// Точка подключения к внешнему хранилищу.
// Провайдер внешнего хранения данных должен в этот указатель положить адрес функции, которая позволит
// получить интерфейс доступа к хранилищу данных.
extern "C" MCTYP_API IExternalDataStoragePtr (*gpGetExternalStorage)();

//==================================================================================================

// Типы данных объекта 3D-тело.
// Значения не менять, сохраняются в файлах.
enum kMc3dPartDataTypeEnum
{
	// Невозможно реализовать. Если отделять, придётся переписать много кода.
	//
	//// Логический состав, имя, тип, составляющие элементы - имя, тип и т.д.
	//// Для дерева истории построения.
	//// По сути - до предела сокращенные структурные данные.
	//kMc3dPartDataType_LogicalStructure = 1,

	// Максимально детальная инфа о составе - данные объектов состава.
	// Для полного перестроения.
	kMc3dPartDataType_SourceModel      = 2,

	// Параметры фич, Wxx элементов, параметры размеров в эскизах.
	// Размер сам по себе блока мал и смысл выносить это в отдельный блок только в том, чтобы обеспечить некую универсальность
	// с точки зрения возможности управления со стороны объектом в черном ящике.
	kMc3dPartDataType_Parameters       = 3,

	// Данные моделера.
	// Например для C3D - это данные объекта MbSolid.
	// Непосредственный результат построения 3D-модели.
	kMc3dPartDataType_ModelerData      = 4,

	// Данные AB-моделера.
	// По факту SAT-поток
	kMc3dPartDataType_SATModelData     = 5,

	// Геометрия. Производное от данных моделера.
	// Для обсчета 3D-зависимостей.
	//   Face/Edge/Vertex ID <-> Geom
	kMc3dPartDataType_GeomCache        = 6,

	// Данные идентификации подобъектов детали.
	// Тут же и данные ref-ключей, имеющихся у детали, у всех её частей.
	kMc3dPartDataType_SubentIdentData  = 7,

	// Графика для отображения. Сетки для преставления 3D-тел.
	kMc3dPartDataType_Graphics_Mesh    = 8,

	// Графика для отображения. Геометрия всего, что не относится к 3D-солидам.
	kMc3dPartDataType_Graphics_Geom    = 9,

	// Состояние тела перед построением очередной 3D-фичи параметрического солида.
	kMc3dPartDataType_PrevBodyState    = 10,
};
//==================================================================================================
