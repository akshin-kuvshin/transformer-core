//
// Копирайт (С) 2019, ООО «Нанософт разработка». Все права защищены.
// 
// Данное программное обеспечение, все исключительные права на него, его
// документация и сопроводительные материалы принадлежат ООО «Нанософт разработка».
// Данное программное обеспечение может использоваться при разработке и входить
// в состав разработанных программных продуктов при соблюдении условий
// использования, оговоренных в «Лицензионном договоре присоединения
// на использование программы для ЭВМ «Платформа nanoCAD»».
// 
// Данное программное обеспечение защищено в соответствии с законодательством
// Российской Федерации об интеллектуальной собственности и международными
// правовыми актами.
// 
// Используя данное программное обеспечение,  его документацию и
// сопроводительные материалы вы соглашаетесь с условиями использования,
// указанными выше. 
//

#pragma once

class McRefEntryMap;

//////////////////////////////////////////////////////////////////////////
//интерфейс предназначен для упрощенного вызова нетовских методов/классов/дилогов, без reference и т.п.
//Т.е. в каком либо net модуле реализуете например диалог или контрол пронаследовавшись от интерфеса IMgdDialog
//в IMcMgdCaller вызываете initClass, не забывайте наймспейс: initClass(_T("mapinet.dll"), _T("Mapinet.McsDBFilterCtl")), 
//если все ок, то через setXXX инициализируете необходимые параметры(они проваливаются в форму через методы IMgdDialog)
//потом Show или CreateControl, не отпускайте IMcMgdCaller до окончания использования контрола
//по окончанию можно через getParam получить какие либо опции
struct IMcMgdCaller : public IMcObject
{
	IMCS_INTERFACE_DEF_CONSTRUSTOR_4KINDOF(IMcMgdCaller);
	IMCS_STD_METHOD_DEFINITION(IMcMgdCaller, IMcObject);
	virtual HRESULT initClass(LPCTSTR module, LPCTSTR className) = 0;
	virtual HRESULT setObjects(const mcsWorkIDArray& ids) = 0;
	virtual HRESULT setParameter(LPCTSTR name, MCSVariant& var) = 0;
	virtual HRESULT getParameter(LPCTSTR name, MCSVariant& var) = 0;
	virtual void setUndoPoint(IMcUndoPoint *pUndo) = 0;
	virtual HRESULT Show(HWND hwnd) = 0;
	virtual IMcWindowPtr CreateControl() = 0;
	virtual IMcMgdCallerPtr CreateControl(LPCTSTR name, mcsVariantArray params) = 0;
	virtual HWND hwnd() = 0;
	virtual HRESULT setValues(int iCount, const exValue* vals) = 0;
	virtual mcsExValueArray getValues() = 0;
};

//------------------------------------------------------------------------------
/// <summary>
/// Интерфейс обеспечивает доступ к объектам Common Language Runtime (CLR) из неуправляемого кода и является
/// альтернативой интерфейсу IMcMgdCaller.
/// </summary>
struct IMcDotNetObject : public IMcObject
{
	IMCS_INTERFACE_DEF_CONSTRUSTOR_4KINDOF(IMcDotNetObject);
	IMCS_STD_METHOD_DEFINITION(IMcDotNetObject, IMcObject);

	/// <summary>
	/// Создаёт CLR-объект указанного типа, используя конструктор по умолчанию.
	/// </summary>
	/// <param name="moduleName">Имя модуля, в котором находится нужный тип.</param>
	/// <param name="typeName">Имя типа, включая пространство имён.</param>
	/// <returns>S_OK, если операция выполнена успешно, в простивном случае E_FAIL.</returns>
	virtual HRESULT Init(LPCTSTR moduleName, LPCTSTR typeName) = 0;

	/// <summary>
	/// Проверяет реализует ли CLR-объект хотя бы один из следующих интерфейсов:
	/// System::Windows::Interop::IWin32Window,
	/// System::Windows::Forms::IWin32Window.
	/// </summary>
	/// <returns>
	/// True, если CLR-объект реализаует хотя бы один из указанных в описании интерфейсов, в противном случае false.
	/// </returns>
	virtual bool IsWindow(void) = 0;
	/// <summary>
	/// Получает дескриптор окна, который предоставляет CLR-объект. Проверить, предоставляет ли CLR-объект дескриптор
	/// окна, можно методом IsWindow().
	/// </summary>
	/// <returns>Дескриптор окна, если CLR-объект предоставляет его, в противном случае NULL.</returns>
	virtual HWND GetWindowHandle(void) = 0;
};

//------------------------------------------------------------------------------
/// <summary>
/// Интерфейс обеспечивает доступ к ряду функций панели дерева истории 3D построений. Сама панель реализована в модуле
/// Mc3DGUI в виде класса Multicad.Mc3D.GUI.Mc3dHistory.PanelInteropControl.
/// </summary>
struct IMc3DHistoryPanel : public IMcObject
{
	IMCS_INTERFACE_DEF_CONSTRUSTOR_4KINDOF(IMc3DHistoryPanel);
	IMCS_STD_METHOD_DEFINITION(IMc3DHistoryPanel, IMcObject);

	/// <summary>
	/// Показывает элемент истории 3D построений с указанным идентификатором в дереве истории 3D построений.
	/// </summary>
	/// <param name="itemId">Идентификатор элемента истории 3D построений.</param>
	virtual void TrackHistoryItem(const mcsWorkID &itemId) = 0;
};

#pragma region RTF

//------------------------------------------------------------------------------
/// <summary>
/// Формат RTF-документа. Форматы, отличаются способом записи различных элементов RTF-документа.
/// </summary>
enum RtfFormat
{
	/// <summary>
	/// Старый формат, применяемый в редакторе CxEdit. Об особенностях данного формата читай в примечаних.
	/// </summary>
	/// <remarks>
	/// <para>
	/// Особенности формата:
	/// </para>
	/// <para>
	/// 1. RTF-внедрения представлены в виде XML-тегов. Общий вид внедрения в RTF выглядит следующим образом:
	/// " \\v\\embo\\impr &lt;[тип_внедрения] [список_атрибутов]&gt;\\v0\\embo0 [значение]\\v\\embo &lt;/тип_внедрения&gt;\\v0\\embo0\\impr0  ",
	/// где атрибуты содержат значения параметров (свойств) внедрения.
	/// </para>
	/// <para>
	/// 2. Индексы представлены управляющими словами \upN и \dnN с указанием размера шрифта \fsN.
	/// </para>
	/// </remarks>
	rtffmtCxEdit,
	/// <summary>
	/// Формат технических требований. Об особенностях данного формата читай в примечаних.
	/// </summary>
	/// <remarks>
	/// <para>
	/// Особенности формата:
	/// </para>
	/// <para>
	/// 1. RTF-внедрения представлены RTF-группами назначения \mcembed. Каждый параметр внедрения заключён в
	/// подгруппу. Пример внедрения типа "гиперссылка":
	/// {\mcembed\mchref{\*\mcaddress https://www.google.ru}{\mcval Google}}.
	/// </para>
	/// <para>
	/// 2. Индексы представлены управляющими словами \sub, \super и \nosupersub.
	/// </para>
	/// </remarks>
	rtffmtTT,
};

//------------------------------------------------------------------------------
// Состояния документа RTF-писателя.

#define RTF_WDS_INITIAL 0 // Начальное. В этим состоянии производится инициализация RTF-писателя. При этом функции формирования RTF-документа не работают, а свойства состояния RTF-писателя принимают значения по умолчанию.
#define RTF_WDS_OPENED  1 // Документ открыт для записи. В этом состоянии производится формирование RTF-документа.
#define RTF_WDS_CLOSED  2 // Документ закрыт для записи. В этом состоянии RTF-документа считается завершенным и его дальнейшее формирование не возможно.

//------------------------------------------------------------------------------
// Флаги содержимого RTF-документа.

#define RTF_CONTENT_TEXT       0x0 // RTF-документ содержит текст.
#define RTF_CONTENT_INDICES    0x1 // RTF-документ содержит индексы и/или дроби.
#define RTF_CONTENT_EMBEDDINGS 0x2 // RTF-документ содержит внедрения.

//------------------------------------------------------------------------------
// Возможности RTF-процессора. Данные флаги используются для настройки RTF-процессора с целью поддержки определённых
// возможностей форматирования.

#define RTF_FEATURE_BASELINE_ALIGNMENT 0x0001 // RTF-процессор допускает выравнивание текста относительно базовой линии.
#define RTF_FEATURE_EMBEDDINGS         0x0002 // RTF-процессор допускает использование ссылок.
#define RTF_FEATURE_TEXT_DECORATIONS   0x0004 // RTF-процессор допускает декорирование текста.
#define RTF_FEATURE_COLORS             0x0008 // RTF-процессор допускает использование различных цветов.
#define RTF_FEATURE_ALL                -1     // Все возможности.

//------------------------------------------------------------------------------
// Специальные флаги, влияющие на работу RTF-читателя.

#define RTF_READER_HIDDEN_TEXT_ALLOWED 0x01 // RTF-читатель позволяет пользователю работать со скрытым текстом.
#define RTF_READER_SINGLE_LINE_OUTPUT  0x02 // RTF-читатель будет игнорировать любые знаки новой строки.
#define RTF_READER_SWAP_OVERLINE_AND_STRIKETHROUGH 0x04 // RTF-читатель будет воспринимать зачёркивание как надчёркивание и наоборот.
#define RTF_READER_CXFTEDIT_INPUT 0x08 // RTF-читатель будет воспринимать тень как надчёркивание и наоборот.
#define RTF_READER_CXFTEDIT_OUTPUT 0x10 // RTF-читатель будет воспринимать тень как зачёркивание и наоборот.
#define RTF_READER_EMBEDDING_AS_IS 0x20 // RTF-читатель будет читать значения внедрений как отдельный RTF-документ.

//------------------------------------------------------------------------------
// Виды выравнивания текста относительно базовой линии в RTF.

#define RTF_BA_BASELINE    1 // Нормальное выравнивание по базовой линии
#define RTF_BA_SUBSCRIPT   2 // Нижний индекс.
#define RTF_BA_SUPERSCRIPT 3 // Верхний индекс.

//------------------------------------------------------------------------------
// Флаги декорирования текста в RTF.

#define RTF_TD_NONE          0x00 // Текст без декораций.
#define RTF_TD_OVERLINE      0x01 // Текст с чертой сверху ("надчёркивание").
#define RTF_TD_STRIKETHROUGH 0x02 // Перечёркнутый текст.
#define RTF_TD_UNDERLINE     0x04 // Подчёркнутый текст.
#define RTF_TD_SHADOW        0x08 // Текст отбрасывает тень.

//------------------------------------------------------------------------------
// Цвет в RTF.

#define RTF_DEFAULT_COLOR 0x80000000 // Цвет по умолчанию, используемый в RTF.
#define RTF_IS_DEFAULT_COLOR(color) (((color) & 0x80000000) != 0) // Проверяет, является ли указанный цвет цветом по умолчанию.

//------------------------------------------------------------------------------
// Типы RTF-внедрений.

#define RTF_ET_UNKNOWN          0 // Тип внедрения неизвестен или не определён.
#define RTF_ET_HYPERLINK        1 // Гиперссылка (ссылка на сетевой ресурс). Описываются интерфейсом IMcRtfEmbeddedHyperlink.
#define RTF_ET_OBJECT           2 // Объект. Описываются интерфейсом IMcRtfEmbeddedObject.
#define RTF_ET_REFERENCE        3 // Ссылка (на свойство). Описываются интерфейсом IMcRtfEmbeddedReference.
#define RTF_ET_SPECPOSREFERENCE 4 // Ссылка на позицию спецификации. Описываются интерфейсом IMcRtfEmbeddedSpecPositionReference.

//------------------------------------------------------------------------------
// Вертикальное выравнивание внедренного в текст объекта геометрии.

#define RTF_OGVA_TOP    0 // Выравнивание по верхнему краю.
#define RTF_OGVA_CENTER 1 // Выравнивание по центру.
#define RTF_OGVA_BOTTOM 2 // Выравнивание по нижнему краю.

//------------------------------------------------------------------------------
// Размер текста индексов и дробей.

#define RTF_FTS_UNKNOWN    -1 // [Только для RTF-фильтра] Размер текста будет взят из исходного RTF-документа.
#define RTF_FTS_DEFAULT     0 // Размер текста индексов и дробей принимается по умолчанию (будет зависеть от параметра PID_FRACTION_TEXT_SIZE).
#define RTF_FTS_BASIC       1 // Размер текста индексов и дробей принимается равным размеру основного текста.
#define RTF_FTS_ONESTEPLESS 2 // Размер текста индексов и дробей будет на одну ступень меньше размера основного текста.

//------------------------------------------------------------------------------
// Базовый интерфейс для всех RTF-внедрений.
struct IMcRtfEmbedding : virtual IMcObject
{
	IMCS_INTERFACE_DEF_CONSTRUSTOR_4KINDOF(IMcRtfEmbedding);
	IMCS_STD_METHOD_DEFINITION(IMcRtfEmbedding, IMcObject);

	// Получает тип внедрения. Типы внедрений представлены макросами вида RTF_ET_xxx.
	virtual int GetType() = 0;

	// Получает значение (текст, отображаемый в редакторе или на чертеже) внедрения.
	virtual McsString GetValue() = 0;
	// Задаёт значение (текст, отображаемый в редакторе или на чертеже) внедрения.
	virtual void SetValue(LPCTSTR lpcszValue) = 0;
};

//------------------------------------------------------------------------------
// Интерфейс RTF-внедрения типа "Гиперссылка".
struct IMcRtfEmbeddedHyperlink : public virtual IMcRtfEmbedding
{
	IMCS_INTERFACE_DEF_CONSTRUSTOR_4KINDOF(IMcRtfEmbeddedHyperlink);
	IMCS_STD_METHOD_DEFINITION(IMcRtfEmbeddedHyperlink, IMcRtfEmbedding);

	// Получает адрес ресурса, на который ссылается гиперссылка.
	virtual McsString GetAddress() = 0;
	// Задаёт адрес ресурса, на который ссылается гиперссылка.
	virtual void SetAddress(LPCTSTR lpcszValue) = 0;
};

//------------------------------------------------------------------------------
// Интерфейс RTF-внедрения типа "Объект".
struct IMcRtfEmbeddedObject : public virtual IMcRtfEmbedding
{
	// Получает идентификатор класса объекта. Если возвращаемый идентификатор пустой, то поток
	// (GetEncodedStream()/SetEncodedStream()) содержит только геометрию объекта.
	virtual GUID GetClassId() = 0;
	// Задаёт идентификатор класса объекта. Если возвращаемый идентификатор пустой, то поток
	// (GetEncodedStream()/SetEncodedStream()) содержит только геометрию объекта.
	virtual void SetClassId(const GUID &id) = 0;

	// Получает закодированный в Base64 поток, который содержит данные объекта.
	// Если идентификатор класса объекта (GetClassId()/SetClassId()) пустой, то поток содержит только геометрию объекта.
	virtual McsString GetEncodedStream() = 0;
	// Задаёт закодированный в Base64 поток, который содержит данные объекта.
	// Если идентификатор класса объекта (GetClassId()/SetClassId()) пустой, то поток содержит только геометрию объекта.
	virtual void SetEncodedStream(LPCTSTR lpcszStream) = 0;

	// Проверяет, вписан ли объект в строку текста. Если возвращаемое значение равно true, то объект (его геометрия)
	// масштабируется таким образом, чтобы его высота была равна высоте строки, в которую он вписан.
	virtual bool IsInscribed() = 0;
	// Задаёт значение, указывающее, должен ли объект быть вписан в строку текста. Если указанное значение равно true,
	// то объект (его геометрия) масштабируется таким образом, чтобы его высота была равна высоте строки, в которую он
	// вписан.
	virtual void SetInscribed(bool inscribed) = 0;

	// Проверяет, необходимо ли сохранять исходный стиль внедряемой геометрии.
	virtual bool IsStyleOverridden() = 0;
	// Задаёт значение, указывающее на необходимость сохранять исходный стиль внедряемой геометрии.
	virtual void SetStyleOverridden(bool overridden) = 0;

	// Получает вертикальное выравнивание геометрии объекта (одно из значений вида RTF_OGVA_xxx).
	virtual int GetVerticalAlignment() = 0;
	// Задаёт вертикальное выравнивание геометрии объекта (одно из значений вида RTF_OGVA_xxx).
	virtual void SetVerticalAlignment(int alignment) = 0;
};

//------------------------------------------------------------------------------
// Интерфейс RTF-внедрения типа "Ссылка" (ссылка на свойство объекта).
struct IMcRtfEmbeddedReference : public virtual IMcRtfEmbedding
{
	// Получает идентификатор ссылки.
	virtual UINT GetId() = 0;
	// Задаёт идентификатор ссылки.
	virtual void SetId(UINT id) = 0;
};

//------------------------------------------------------------------------------
// Интерфейс RTF-внедрения типа "Ссылка на позицию спецификации".
struct IMcRtfEmbeddedSpecPositionReference : public virtual IMcRtfEmbedding
{
	// Получает идентификтор выноски.
	virtual GUID GetSpecLeaderId() = 0;
	// Задаёт идентификтор выноски.
	virtual void SetSpecLeaderId(const GUID &id) = 0;

	// Получает идентификатор объекта спецификации.
	virtual GUID GetSpecObjectId() = 0;
	// Задаёт идентификатор объекта спецификации.
	virtual void SetSpecObjectId(const GUID &id) = 0;

	// Получает идентификатор записи.
	virtual int GetRecordId() = 0;
	// Задаёт идентификатор записи.
	virtual void SetRecordId(int id) = 0;

	// Получает позицию.
	virtual McsString GetPosition() = 0;
	// Задаёт позицию.
	virtual void SetPosition(LPCTSTR lpcszPosition) = 0;

	// Получает зону формата.
	virtual McsString GetZone() = 0;
	// Задаёт зону формата.
	virtual void SetZone(LPCTSTR lpcszZone) = 0;
};

//------------------------------------------------------------------------------
// Интерфейс предоставляет методы категории состояния RTF-писателя IMcRtfWriterState, отвечающей за отображение текста,
// например: каким цветом выводится текст, как он расположен относительно базовой линии, какова высота символов и т.д.
struct IMcRtfWriterTextFormat
{
	// Получает способ выравнивания текста относительно базовой линии (одно из значений вида RTF_BA_xxx).
	virtual int GetBaselineAlignment() = 0;
	// Задаёт способ выравнивания текста относительно базовой линии (одно из значений вида RTF_BA_xxx).
	virtual void SetBaselineAlignment(int alignment) = 0;

	// Получает размер шрифта (высоту символов) в полупунктах. Например, для значения 24 размер шрифта будет 12pt.
	virtual int GetFontSize() = 0;
	// Задаёт размер шрифта (высоту символов) в полупунктах. Например, для значения 24 размер шрифта будет 12pt.
	virtual void SetFontSize(int size) = 0;

	// Получает декорации текста (комбинациея значений вида RTF_TD_xxx).
	virtual int GetTextDecorations() = 0;
	// Задаёт декорации текста (комбинациея значений вида RTF_TD_xxx).
	virtual void SetTextDecorations(int decorations) = 0;

	// Проверяет, является ли текст скрытым.
	virtual bool IsTextHidden() = 0;
	// Указывает, должен ли текст быть скрытым.
	virtual void SetTextHidden(bool hidden) = 0;

	// Получает цвет фона текста. Проверить, является ли возвращаемый цвет цветом по умолчанию, можно с помощью макроса
	// RTF_IS_DEFAULT_COLOR(color).
	virtual COLORREF GetBackgroundColor() = 0;
	// Задаёт цвет фона текста. Используйте макрос RTF_DEFAULT_COLOR, чтобы задать цвет по умолчанию.
	virtual void SetBackgroundColor(COLORREF color) = 0;

	// Получает цвет шрифта. Проверить, является ли возвращаемый цвет цветом по умолчанию, можно с помощью макроса
	// RTF_IS_DEFAULT_COLOR(color).
	virtual COLORREF GetForegroundColor() = 0;
	// Задаёт цвет шрифта. Используйте макрос RTF_DEFAULT_COLOR, чтобы задать цвет по умолчанию.
	virtual void SetForegroundColor(COLORREF color) = 0;

	// Фиксирует формат текста. Фиксация формата немедленно приводит к записи всех изменившихся с последней фиксации
	// свойств в виде управляющих слов. Фиксация производится RTF-писателем автоматически перед записью неуправляющего
	// текста.
	virtual void Fix() = 0;

	// Сбрасывает формат текста в формат по умолчанию.
	virtual void Reset() = 0;
};

//------------------------------------------------------------------------------
// Интерфейс предоставляет методы состояния RTF-писателя IMcRtfWriter.
//   Для удобаства использования состояние RTF-писателя делится на категории свойств. Каждая категория свойств отвечает
// за форматирование того или иного вида элементов RTF-документа. Каждое свойство из категории в RTF-документе будет
// представлена в виде управляющих слов, которые записываются во время фиксации изменений состояния, производимой
// методом Fix().
//   Работа с состоянием RTF-писателя выглядит очень просто. Для этого достаточно просто задать нужные значения
// свойствам доступных категорий. Затем нужно вызвать метод Fix() для того, чтобы свойства были записаны в RTF-документ.
// Хотя, как правило, RTF-писатель сам вызывает метод Fix(), перед записью неуправляющего текста в документ, поэтому,
// как правило, вызывать его вручную не требуется.
struct IMcRtfWriterState
{
	// Получает категорию свойств, отвечающую за форматирование текста.
	virtual IMcRtfWriterTextFormat& GetTextFormat() = 0;

	// Фиксирует изменения, производя запись управляющего текста с помощью RTF-писателя.
	virtual void Fix() = 0;
};

//------------------------------------------------------------------------------
// Интерфейс предоставляет методы RTF-писателя.
//   RTF-писатель предназначен для формирования RTF-документа требуемого формата, который указывается при инициализации
// писателя. Существует два метода роботы с RTF-писателем: высокоуровневый и низкоуровневый.
//   Высокоуровневый метод работы является основополагающим, так как учитывает все особенности форматирования сложных
// элементов документа, и предполагает использование состояния писателя и методов формирования сложных элементов
// документа (например, внедрений).
//   Низкоуровневые возможности, такие как создание RTF-группы или запись управляющего слова, следует использовать
// только в тех случаях, когда высокоуровневых не достаточно.
//   В общих чертах, работа с RTF-писателем происходит следующим образом:
//     1. Создаётся объект типа IMcRtfWriter и инициализируется методом Init() с указанием требуемого формата.
//     2. Задаются параметры по умолчанию посредством состояния писателя.
//     3. Выполняется открытие документа для записи вызовом OpenDocument().
//     4. Формируется тело RTF-документа посредством интерфейса писателя и его состояния, которое можно получить методом
//        GetState().
//     5. Выполняется окончательное формирование RTF-документа вызовом метода CloseDocument().
//   Результат работы RTF-писателя можно получить методами GetRtfText() и GetUnicodeText().
//
// Пример:
//
// IMcRtfWriterPtr pRtfWriter = gpMcObjManager->createObject(IID_IMcRtfWriter);
// pRtfWriter->Init(rtffmtCxEdit);
//
// pRtfWriter->GetState().GetTextFormat().SetFontSize(18); // задать размер шрифта по умолчанию 9pt
//
// pRtfWriter->OpenDpcument();
//
// IMcRtfEmbeddedHyperlinkPtr pHyperlink = gpMcObjManager->createObject(IID_IMcRtfEmbeddedHyperlink);
// pRtfWriter->BeginEmbedding(pHyperlink);
// pHyperlink->SetAddress(_T("https://www.google.ru/"));
// pRtfWriter->Write(_T("Google"));
// pRtfWriter->CloseEmbedding();
//
// pRtfWriter->BeginNewParagraph();
//
// pRtfWriter->GetState().GetTextFormat().SetForegroundColor(RGB(255, 0, 0));
// pRtfWriter->Write(_T("red"));
// pRtfWriter->GetState().GetTextFormat().SetForegroundColor(RGB(0, 255, 0));
// pRtfWriter->Write(_T(" green"));
// pRtfWriter->GetState().GetTextFormat().SetForegroundColor(RGB(0, 0, 255));
// pRtfWriter->Write(_T(" blue"));
// pRtfWriter->GetState().GetTextFormat().SetForegroundColor(RTF_DEFAULT_COLOR);
// pRtfWriter->Write(_T(" text."));
//
// pRtfWriter->CloseDocument();
//
// wprintf(_T("RTF text:\r\n%s\r\nUNICODE text:\r\n%s"),
//	(LPCTSTR)pRtfWriter->GetRtfText(),
//	(LPCTSTR)pRtfWriter->GetUnicodeText());
//
// Результат работы примера:
// RTF text:
// {\rtf1\ansi\deff0{\fonttbl{\f0\fnil\fcharset0 CS Standard;}}
// {\colortbl ;\red255\green0\blue0;\red0\green255\blue0;\red0\green0\blue255;}
// \fs20 {\mcembed\mchref{\*\mcaddress https://www.google.ru/}{\mcval Google}}\par\cf1 red\cf2  green\cf3  blue\cf0  text.}
//
// UNICODE text:
// Google
// red green blue text.
struct IMcRtfWriter : public IMcObject
{
	IMCS_INTERFACE_DEF_CONSTRUSTOR_4KINDOF(IMcRtfWriter);
	IMCS_STD_METHOD_DEFINITION(IMcRtfWriter, IMcObject);

	// Инициализирует RTF-писатель. Данный метод необходимо вызвать перед началом работы с RTF-писателем.
	virtual bool Init(RtfFormat format) = 0;

	// Получает формат RTF-документа, который был указан при инициализации писателя. Об отличиях форматов RTF-документа
	// можно прочитать в их описании в перечислении RtfFormat.
	virtual RtfFormat GetFormat() = 0;

	// Получает размер текста индексов и дробей.
	// Возвращаемое значение:
	//  Значение вида RTF_FTS_XXX.
	virtual int GetFractionTextSize() = 0;
	// Задаёт размер текста индексов и дробей. Вызов данного метода должен быть совершен до вызова метода CloseDocument(),
	// в противном случае вызов не возымеет эффекта.
	// Параметры:
	//  - fractionTextSize: значение вида RTF_FTS_XXX.
	virtual void SetFractionTextSize(int fractionTextSize) = 0;

	// Получает текущее состояние писателя. Возвращаемый данным методом интерфейс, представляющий состояние писателя,
	// всегда один и тот же, изменяются только значения свойств его категорий (см. описание IMcRtfWriterState).
	// Текущее состояние сохраняется каждый раз, когда писатель вызовом одного из методов с именем BeginGroup
	// начинает новую RTF-группу, и восстанавливается, когда писатель закрывает группу вызовом метода CloseGroup().
	virtual IMcRtfWriterState& GetState() = 0;

	//   Получает значение, указывающее, содержит ли полученный документ RTF-текст. По умолчанию false. Принимает
	// значение true, как только появляется управляющий текст, который не может быть заменён неуправляющим текстом.
	//   RTF-писатель в процессе работы одновременно формирует два типа документа: в формате RTF и простой UNICODE-текст.
	// Так вот, получаемое методом ContainsControlText() значение показывает, может ли RTF-текст быть заменён простым
	// UNICODE-текстом без потери его форматирования. Такая ситуация возможна только в том случае, если RTF-документ
	// (исключая заголовок) содержит только те управляющие слова, которые можно заменить символами неуправляющего текста
	// (например, \tab можно заменить на '\t', \par - на пару "\r\n").
	virtual bool ContainsControlText() = 0;
	// Получает текст сформированного документа в формате RTF.
	virtual McsString GetRtfText() = 0;
	// Получает текст сформированного документа в формате UNICODE.
	virtual McsString GetUnicodeText() = 0;

	// Получает флаги вида RTF_CONTENT_XXX содержимого RTF-документа. Флаги выставляются автоматически, как только
	// RTF-писатель встречает нужную конструкцию. Однако, можно установить флаги вручную методом AddContent().
	virtual int GetContent() = 0;
	// Позволяет установить флаги содержимого RTF-документа вручную. Получить флаги можно методом GetContent().
	// Параметры:
	//  - content: флаги содержимого вида RTF_CONTENT_XXX, которые нужно установить..
	// Возвращаемое значение:
	//  Все флаги вида RTF_CONTENT_XXX, установленные в RTF-писателе.
	virtual int AddContent(int content) = 0;

	// Получает состояние документа (значения вида RTF_WDS_xxx).
	virtual int GetDocumentState() = 0;
	// Открывает документ, если он ещё не открыт для записи. При этом состояние документа (можно получить методом
	// GetDocumentState()) изменяет своё значение на RTF_WDS_OPENED.
	// Возвращаемое значение:
	//  True, если в момент вызова метода состояние документа было RTF_WDS_INITIAL, и false в противном случае.
	virtual bool OpenDocument() = 0;
	// Закрывает RTF-документ: записывает заголовок и закрывает все незакрытые RTF-группы. Только после вызова данного
	// метода RTF-документ считается окончательно сформированным.
	// Возвращаемое значение:
	//  True, если в момент вызова метода состояние документа было RTF_WDS_OPENED, и false в противном случае.
	virtual bool CloseDocument() = 0;

	// Начинает новую строку. Иными словами, дописывает пару CRLF ("\r\n") в конец текстового буфера RTF-документа.
	// Пара CRLF не рассматривается как текст документа и применяется исключительно для структурирования текста
	// RTF-документа.
	virtual void NewLine() = 0;

	// Начинает новую RTF-группу. Выполняет фиксацию состояния писателя (см. описание методы IMcRtfWriterState::Fix()).
	// Возвращаемое значение:
	//  Уровень новой RTF-группы или -1, если документ не в состоянии RTF_WDS_OPENED.
	virtual int BeginGroup() = 0;
	// Начинает новую RTF-группу назначения (см. спецификацию RTF). Выполняет фиксацию состояния писателя (см. описание
	// методы IMcRtfWriterState::Fix()).
	// Параметры:
	//  - lpcszDestination: имя назначения.
	// Возвращаемое значение:
	//  Уровень новой RTF-группы или -1, если документ не в состоянии RTF_WDS_OPENED.
	virtual int BeginGroup(LPCTSTR lpcszDestination) = 0;
	// Начинает новую RTF-группу назначения, содержимое которой может быть проигнорировано RTF-читателем, если
	// назначение не будет распознано. Выполняет фиксацию состояния писателя (см. описание методы IMcRtfWriterState::Fix()).
	// Параметры:
	//  - lpcszDestination: имя назначения;
	//  - canBeIgnored: указывает, может ли содержимое группы быть проигнорировано RTF-читателем.
	// Возвращаемое значение:
	//  Уровень новой RTF-группы или -1, если документ не в состоянии RTF_WDS_OPENED.
	virtual int BeginGroup(LPCTSTR lpcszDestination, bool canBeIgnored) = 0;
	// Закрывает текущую RTF-группу. Восстанавливает состояние RTF-писателя в актуальное для вышестоящей RTF-группы.
	// Возвращаемое значение:
	//  Уровень вышестоящей RTF-группы или -1, если все группы уже закрыты (конец документа) или документ не
	//  в состоянии RTF_WDS_OPENED.
	virtual int CloseGroup() = 0;
	// Получает уровень текущей RTF-группы. Отсчёт уровней ведётся с нуля (уровень главной группы RTF-документа).
	virtual int GetGroupLevel() = 0;

	// Записывает фрагмент неуправляющего текста в RTF-документ. Прежде чем текст попадёт в документ, он будет
	// перекодирован в соостветствии с требованиями формата RTF. Выполняет фиксацию состояния писателя (см.
	// описание методы IMcRtfWriterState::Fix()).
	// Параметры:
	//  - lpcszText: фрагмент текста для записи в документ.
	virtual void Write(LPCTSTR lpcszText) = 0;
	// Записывает фрагмент неуправляющего текста в RTF-документ. Позволяет записать служебный текст. Служебный
	// текст не попадает в документ формата UNICODE. Прежде чем текст попадёт в документ, он будет перекодирован
	// в соостветствии с требованиями формата RTF. Выполняет фиксацию состояния писателя (см. описание методы
	// IMcRtfWriterState::Fix()).
	// Параметры:
	//  - lpcszText: фрагмент текста для записи в документ;
	//  - service: флаг, указывающий, является ли указанный фрагмент текста служебным.
	virtual void Write(LPCTSTR lpcszText, bool service) = 0;

	// Записывает управляющее слово с указанным именем в RTF-документ.
	// ВНИМАНИЕ! Имя управляющего слова должно содержать только буквы латинского алфавита. Метод не проверяет имя
	// управляющего слова.
	// После вызова данного метода возвращаемое методом ContainsControlText() значение становится true независимо
	// от имени управляющего слова.
	// Параметры:
	//  - lpcszControlWordName: имя управляющего слова.
	virtual void WriteControlWord(LPCTSTR lpcszControlWordName) = 0;
	// Записывает управляющее слово с указанным именем и 16-разрядным параметром в RTF-документ.
	// ВНИМАНИЕ! Имя управляющего слова должно содержать только буквы латинского алфавита. Метод не проверяет имя
	// управляющего слова.
	// После вызова данного метода возвращаемое методом ContainsControlText() значение становится true независимо
	// от имени управляющего слова.
	// Параметры:
	//  - lpcszControlWordName: имя управляющего слова;
	//  - parameter: 16-разрядный числовой параметр.
	virtual void WriteControlWord(LPCTSTR lpcszControlWordName, short parameter) = 0;
	// Записывает управляющее слово с указанным именем и 32-разрядным параметром в RTF-документ.
	// ВНИМАНИЕ! Имя управляющего слова должно содержать только буквы латинского алфавита. Метод не проверяет имя
	// управляющего слова.
	// После вызова данного метода возвращаемое методом ContainsControlText() значение становится true независимо
	// от имени управляющего слова.
	// Параметры:
	//  - lpcszControlWordName: имя управляющего слова;
	//  - parameter: 32-разрядный числовой параметр.
	virtual void WriteControlWord(LPCTSTR lpcszControlWordName, int parameter) = 0;

	// Начинает запись внедрения. Для завершения записи необходимо вызвать метод CloseEmbedding().
	//   Запись внедрения производится в три этапа:
	// 1. Начало записи внедрения. Сопровождается вызовом метода BeginEmbedding(), который выполняет подготовку к
	// записи внедрения. На этом этапе не требуется наличие актуальных данных внедрения.
	// 2. Запись значения внедрения. На этом этапе производится запись произвольного управляющего и неуправляющего
	// текста, который будет выступать в качестве значения внедрения.
	// 3. Завершение записи внедрения. Сопровождается вызовом метода CloseEmbedding(). На этом этапе данные внедрения,
	// указанного методом BeginEmbedding(), уже должны иметь актуальные значения.
	// Параметры:
	//  - embedding: указатель на интерфейс, осуществляющий доступ к данным внедрения. Создание объекта, реализующего
	//               интерфейс IMcRtfEmbedding можно вызовом gpMcObjManager->createObject(IID_IMcRtfEmbedded...).
	// Возвращаемое значение:
	//  False, если документ находится не в состоянии RTF_WDS_OPENED, в данный момент производится запись другого
	//  внедрения или параметр pEmbedding имеет значение NULL. В остальных случаях метод возвращает значение true.
	virtual bool BeginEmbedding(IMcRtfEmbedding* pEmbedding) = 0;
	// Завершает запись внедрения, начатую вызовом метода BeginEmbedding(). Подробнее смотри описание метода BeginEmbedding().
	// Возвращаемое значение:
	//  False, если документ находится не в состоянии RTF_WDS_OPENED, в данный момент запись внедрения не производится
	//  или в результате ошибки. В остальных случаях метод возвращает значение true.
	virtual bool CloseEmbedding() = 0;
	// Производит запись внедрения, используя указанные в нём данные.
	// Параметры:
	//  - embedding: внедрение, которое нужно записать в документ.
	// Возвращаемое значение:
	//  True, если внедрение было успешно записано, и false, если документ находится не в состоянии RTF_WDS_OPENED,
	//  параметр pEmbedding имеет значение NULL, в данный момент производится запись другого внедрения или при записи
	//  внедрения произошла ошибка.
	virtual bool WriteEmbedding(IMcRtfEmbedding* pEmbedding) = 0;

	// Начинает новый параграф. RTF-писатель изначально имеет открытый параграф, поэтому данный метод не требуется
	// вызывать для первого параграфа в документе.
	virtual void BeginNewParagraph() = 0;
	// Закрывает текущий параграф.
	virtual void CloseCurrentParagraph() = 0;
};

//------------------------------------------------------------------------------
// Используется в методах IMcRtfFilter::Filter().
#define FILTER(sourceText)              \
	SetSourceText(sourceText);          \
	SetFormat(format);                  \
	SetFeatures(features);              \
	SetFlags(flags);                    \
	SetTargetObjectId(idTargetObject);  \
	Execute();                          \
	if(!UnicodeResultPreferable())      \
		GetRtfText(OUT result);         \
	else                                \
		GetUnicodeText(OUT result);

// Интерфейс RTF-фильтра, который реализован в модуле imapimgd.dll.
struct IMcRtfFilter : public IMcObject
{
	IMCS_INTERFACE_DEF_CONSTRUSTOR_4KINDOF(IMcRtfFilter);
	IMCS_STD_METHOD_DEFINITION(IMcRtfFilter, IMcObject);

	// Фильтрует текст, формируя результат в указанном формате.
	// Параметры:
	//	- lpcszText: исходный текст, который требуется отфильтровать;
	//	- result: ссылка на объект типа McsString, которая будет содержать результат работы фильтра;
	//	- features: возможности фильтра при чтении исходного текста. Комбинация флагов вида RTF_FEATURE_XXX;
	//	- flags: флаги фильтра, влияющие на чтение исходного текста. Комбинация флагов вида RTF_READER_XXX;
	//  - idTargetObject: целевой объект, ссылки которого могут содержаться в тексте lpcszText. Необходим для
	//    преобразования RTF-текста из формата CxFtEdit в формат для хранения в базе. В Остальных случаях не требуется;
	//	- format: формат, в котором должен быть сформирован результат.
	// Возвращаемое значение:
	//	Метод возвращает значение через параметр result.
	// Примечания:
	//	Результат работы фильтра может быть в формате RTF или UNICODE. Результат в формат UNICODE может быть в том
	//	случае, если итоговый документ не содержит управляющий текст, который не может быть заменён символами
	//	неуправляющего текста.
	void Filter(LPCSTR lpcszText, OUT McsString &result,
		int features = RTF_FEATURE_ALL & ~RTF_FEATURE_COLORS,
		int flags = 0,
		const mcsWorkID &idTargetObject = mcsWorkID(),
		RtfFormat format = rtffmtCxEdit)
	{
		FILTER(lpcszText);
	}
	// Фильтрует текст, формируя результат в указанном формате.
	// Параметры:
	//	- lpcszText: исходный текст, который требуется отфильтровать;
	//	- result: ссылка на объект типа McsString, которая будет содержать результат работы фильтра;
	//	- features: возможности фильтра при чтении исходного текста. Комбинация флагов вида RTF_FEATURE_XXX;
	//	- flags: флаги фильтра, влияющие на чтение исходного текста. Комбинация флагов вида RTF_READER_XXX;
	//	- idTargetObject: целевой объект, ссылки которого могут содержаться в тексте lpcszText. Необходим для
	//	  преобразования RTF-текста из формата CxFtEdit в формат для хранения в базе. В Остальных случаях не требуется;
	//	- format: формат, в котором должен быть сформирован результат.
	// Возвращаемое значение:
	//	Метод возвращает значение через параметр result.
	// Примечания:
	//	Результат работы фильтра может быть в формате RTF или UNICODE. Результат в формат UNICODE может быть в том
	//	случае, если итоговый документ не содержит управляющий текст, который не может быть заменён символами
	//	неуправляющего текста.
	void Filter(LPCWSTR lpcszText, OUT McsString &result,
		int features = RTF_FEATURE_ALL & ~RTF_FEATURE_COLORS,
		int flags = 0,
		const mcsWorkID &idTargetObject = mcsWorkID(),
		RtfFormat format = rtffmtCxEdit)
	{
		FILTER(lpcszText);
	}

	// Получает возможности фильтра при чтении исходного текста.
	// Возвращаемое значение:
	//	Комбинация флагов вида RTF_FEATURE_XXX.
	virtual int GetFeatures() = 0;
	// Задаёт возможности фильтра при чтении исходного текста.
	// Параметры:
	//	- features: возможности фильтра при чтении исходного текста. Комбинация флагов вида RTF_FEATURE_XXX.
	virtual void SetFeatures(int features) = 0;
	// Получает флаги фильтра, влияющие на чтение исходного текста.
	// Возвращаемое значение:
	//	Комбинация флагов вида RTF_READER_XXX.
	virtual int GetFlags() = 0;
	// Задаёт флаги фильтра, влияющие на чтение исходного текста.
	// Параметры:
	//	- flags: флаги фильтра, влияющие на чтение исходного текста. Комбинация флагов вида RTF_READER_XXX.
	virtual void SetFlags(int flags) = 0;
	// Получает формат, в котором должен быть сформирован результат.
	// Возвращаемое значение:
	//	Одно из значений перечисления RtfFormat.
	virtual RtfFormat GetFormat() = 0;
	// Задаёт формат, в котором должен быть сформирован результат.
	// Параметры:
	//	- format: формат, в котором должен быть сформирован результат.
	virtual void SetFormat(RtfFormat format) = 0;
	// Получает размер шрифта (высоту символов) в полупунктах по умолчанию. Например, для значения 24 размер шрифта будет 12pt.
	virtual int GetDefaultFontSize() = 0;
	// Задаёт размер шрифта (высоту символов) в полупунктах по умолчанию. Например, для значения 24 размер шрифта будет 12pt.
	virtual void SetDefaultFontSize(int fontSize) = 0;

	// Получает размер текста индексов и дробей. Если фильтру методом SetFractionTextSize() не задано значение отличное
	// от RTF_FTS_UNKNOWN, то по окончинии работы фильтра данным методом можно получить размер текста индексов и дробей
	// исходного текста.
	// Возвращаемое значение:
	//  Значение вида RTF_FTS_XXX.
	virtual int GetFractionTextSize() = 0;
	// Задаёт размер текста индексов и дробей. Вызов данного метода должен быть выполнен до начала работы фильтра.
	// Если фильтру данным методом не задано значение отличное от RTF_FTS_UNKNOWN, то по окончинии работы фильтра методом
	// GetFractionTextSize() можно получить размер текста индексов и дробей исходного текста. Это следует учитывать при
	// повторном использовании фильтра.
	// Параметры:
	//  - fractionTextSize: значение вида RTF_FTS_XXX.
	virtual void SetFractionTextSize(int fractionTextSize) = 0;

	// Подготавливает фильтр к процедуре копирования указанных ссылок в свойство целевого объекта.
	// Параметры:
	//	- mapRefEntry: словарь ссылок, которые предстоит скопировать. Из данного словаря будут скопированы только те
	//	  ссылки, что присутствуют в исходном тексте, указанном методом SetSourceText(). Если ссылка присутствует в
	//	  исходном тексте, но отсутствует в данном словаре, то в итоге она будет превращена в простой текст. Может быть
	//	  пустым.
	//	- idTargetObject: идентификатор целевого объекта, в который должны быть скопированы ссылки.
	//	- lpszTargetPropertyName: имя текстового свойства целевого объекта, которое в итоге должно содержать текст с
	//	  ссылками.
	// Возвращаемое значение:
	//	Если 
	virtual bool PrepareForCopyReferences(const McRefEntryMap &mapRefEntry, const mcsWorkID &idTargetObject, LPCTSTR lpszTargetPropertyName) = 0;
	// Задаёт исходный текст для фильтрации.
	// Параметры:
	//	- lpcszText: исходный текст, который требуется отфильтровать.
	virtual void SetSourceText(LPCSTR lpcszText) = 0;
	// Задаёт исходный текст для фильтрации.
	// Параметры:
	//	- lpcszText: исходный текст, который требуется отфильтровать.
	virtual void SetSourceText(LPCWSTR lpcszText) = 0;
	// Получает идентификатор целевого объекта, текст одного из свойств которого обрабатывается данным фильтром.
	// Возвращаемое значение:
	//	Идентификатор объекта, заданный методом SetTargetObjectId.
	virtual mcsWorkID GetTargetObjectId() = 0;
	// Задаёт идентификатор целевого объекта, текст одного из свойств которого обрабатывается данным фильтром.
	// Необходим для преобразования RTF-текста из формата CxFtEdit в формат для хранения в базе.
	// Параметры:
	//	- id: идентификатор объекта.
	virtual void SetTargetObjectId(const mcsWorkID &id) = 0;

	// Запускает фильтр.
	virtual void Execute() = 0;

	// Получает значение, указывающее, является ли результат в формате UNICODE предпочтительным, то есть может ли
	// итоговый RTF-документ быть заменён документом в формате UNICODE. Такая ситуация возможна в том случае, если
	// итоговый RTF-документ содержит только тот управляющий текст, который может быть заменён неуправляющим текстом.
	// Возвращаемое значение:
	//	True, если результат в формате UNICODE является предпочтительным, и false в противном случае. Для первого случая
	//	итоговый документ можно получить методом GetUnicodeText(), а для второго методом GetRtfText().
	virtual bool UnicodeResultPreferable() = 0;
	// Получает флаги вида RTF_CONTENT_XXX содержимого RTF-документа, получившегося на выходе фильтра.
	virtual int GetContent() = 0;
	// Получает документ в формате RTF, представляющий результат работы фильтра.
	// Параметры:
	//	- sText: ссылка на объект типа McsString, в который будет помещён текст в формате RTF.
	virtual void GetRtfText(OUT McsString& sText) = 0;
	// Получает документ в формате UNICODE, представляющий результат работы фильтра.
	// Параметры:
	//	- sText: ссылка на объект типа McsString, в который будет помещён текст в формате UNICODE.
	virtual void GetUnicodeText(OUT McsString& sText) = 0;

	// Производит обновление ссылок в указанном тексте.
	// Параметры:
	//	- sText: ссылка на объект типа McsString, в котором находится текст, который может содержать ссылки.
	//		После завршения процесса обновления данный объект будет содержать новый текст. Как правило, через этот
	//		парамтр передаётся текст одного из свойств объекта с идентификатором, указываемым в параметре idTargetObject.
	//	- idTargetObject: идентификатор объекта, который содержит информацию о ссылках;
	//	- pUpdatedRefIds: указатель на массив идентификаторов ссылок. Может быть NULL.
	//		Если данный указатель указывает на пустой массив, то после завершения работы метода массив будет содержать
	//		идентификаторы ссылок, реально присутствующих в указанном тексте. Если же массив не пустой, то из него
	//		будут удалены идентификаторы ссылок, реально присутствующих в указанном тексте.
	virtual void UpdateReferences(IN OUT McsString &sText, const mcsWorkID &idTargetObject, IN OUT McsArray<DWORD> *pUpdatedRefIds = NULL) = 0;
};

struct IMcRtfUtils : public IMcObject
{
	IMCS_INTERFACE_DEF_CONSTRUSTOR_4KINDOF(IMcRtfUtils);
	IMCS_STD_METHOD_DEFINITION(IMcRtfUtils, IMcObject);

	// Объединяет два текстовых документа в один, формируя результат в указанном формате.
	// Параметры:
	//  - lpcszText1: первый текстовый документ. Может быть как в формате RTF, так и простым текстом;
	//  - lpcszText2: второй текстовый документ. Может быть как в формате RTF, так и простым текстом;
	//  - flags: флаги, влияющие на чтение исходного текста. Комбинация флагов вида RTF_READER_XXX;
	//  - format: формат, в котором должен быть сформирован результат;
	//  - features: возможности при чтении исходного текста. Комбинация флагов вида RTF_FEATURE_XXX.
	// Возвращаемое значение:
	//	Метод возвращает в точку вызова текстовый документ, котрый является результатом объединения двух указанных
	//  текстовых документов.
	// Примечания:
	//	Результат работы метода может быть в формате RTF или UNICODE. Результат в формат UNICODE может быть в том
	//	случае, если итоговый документ не содержит управляющий текст, который не может быть заменён символами
	//	неуправляющего текста.
	virtual McsString Concat(LPCTSTR lpcszText1, LPCTSTR lpcszText2, int flags, RtfFormat outputFormat = rtffmtCxEdit, int features = RTF_FEATURE_ALL) = 0;
};

#pragma endregion
